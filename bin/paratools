#!/usr/bin/env python
"""
Usage:

    paratools CMD [ --help | ... ]

where CMD is one of the following:

    energy              Compute and print total energy in eV
    forces              Compute and print forces in eV/A
    frequencies         Compute frequencies by numerical
                        differentiation of forces

    minimize            minimizes the geometry, default is by BFGS
    dimer               transition state search with eigenmode using
                        dimer method for finding lowest eigenmode
    lanczos             transition state search with eigenmode using
                        lanczos algorithm to find lowest eigenmode

    dimer-rotate        using dimer rotation for finding lowest
                        eigenmode (no update steps for geometry)
    lanczos-rotate      using lanczos algorithm to find lowest
                        eigenmode (as dimer-rotate)

    neb                 Nudged Elastic Band calculation
    ci-neb              Nudged Elastic Band with climbing image
    string              String optimization, similar to NEB
    growingstring
    searchingstring
    ci-string,  ...     climbing image additional to string, works
                        also with growingstring and searchingstring
    path-searcher       Is capable of doing all of the above


    make-path           interpolate a path without optimizing it
    jmol                show interpolated path with jmol

    find-limit-path     Find first appearance where some limits are
                        met in the output logfile
    path2plot           internal coordinate plot for some path
    path2tab            internal coordinates from path
    path2xyz            convert path to xyz file(s)
    xyz2tab             get internal coordinates from xyz-file(s)
    tab2plot            plots a tabular as given by xyz2tab
    ts-and-mods         Shows TS estimates and mode vector for a path
    pp2ts-err           see error of ts_estimates of path to real TS
                        (given also as input)
    min-iter            Gives iteration with minimal value from
                        logfile

See subcommand specific help for syntax details.

Examples:

    paratools string --help
    paratools string --calculator default_vasp POSCAR-A POSCAR-B

Search transition path between A and B using default VASP settings.
"""
import sys
from ase.optimize import *  # to recognise the optimizers lateron
import pts.tools.findlimitpath
import pts.tools.jmol
import pts.tools.makepath
import pts.tools.pathmin
import pts.tools.path2xyz
import pts.tools.path2tab
import pts.tools.pp2tserr
import pts.tools.tsestandmods
import pts.tools.xyz2tabint
import pts.vib
import pts.path_searcher

optic_methods = {
   "tab2plot"        : True       ,
   "path2plot"       : True       ,
}

methods = {
   "path-searcher"   : pts.path_searcher.main  ,
   "path_searcher"   : pts.path_searcher.main  ,
   "frequencies"     : pts.vib.main                  ,
   "find-limit-path" : pts.tools.findlimitpath.main  ,
   "find_limit_path" : pts.tools.findlimitpath.main  ,
   "jmol"            : pts.tools.jmol.main           ,
   "make-path"       : pts.tools.makepath.main       ,
   "make_path"       : pts.tools.makepath.main       ,
   "path2xyz"        : pts.tools.path2xyz.main       ,
   "path2tab"        : pts.tools.path2tab.main       ,
   "pp2ts-err"       : pts.tools.pp2tserr.main       ,
   "pp2ts_err"       : pts.tools.pp2tserr.main       ,
   "ts-and-mods"     : pts.tools.tsestandmods.main   ,
   "ts_and_mods"     : pts.tools.tsestandmods.main   ,
   "min_iter"        : pts.tools.pathmin.main   ,
   "min-iter"        : pts.tools.pathmin.main   ,
   "xyz2tab"         : pts.tools.xyz2tabint.main
}

def main(argv):
    """Subcommand dispatcher, depending on argv[0] call subcommand
    specific methods. To be used as main(sys.argv[1:]).
    """

    if len(argv) < 1:
        print >> sys.stderr, __doc__
        sys.exit(1)

    # first argument is the keyword for the subtask:
    cmd = argv[0]

    # is this a valid command?
    valid_cmd = False

    # the rest of the command line is delegated to the
    # subtask for interpretation:
    if cmd in ("energy", "forces"):
        valid_cmd = True

        # print "pts: call single_point(", argv[1:], ")"
        single_point(argv)

    if cmd == "minimize":
        valid_cmd = True
        minimize(argv[1:])

    if cmd in ("string", "neb", "ci-neb", "growingstring", "searchingstring",
               "ci-string", "ci-growingstring", "ci-searchingstring",
               "sopt"):
        valid_cmd = True

        # import right here in order not to import everything,
        # while using only one specific method:
        from pts.path_searcher import main as pathsearcher

        # prepend a flag for pathsearcher to understand the method:
        argv1 = ["--method"] + argv
        # print "pts: call pathsearcher(", argv1, ")"
        pathsearcher(argv1)

    if cmd in ("dimer", "lanczos"):
        valid_cmd = True

        # import right here in order not to import everything,
        # while using only one specific method:
        from pts.dimer import main as ts_search

        # First relevant argument might be special
        # Main expects that the very first element is only about itself
        argv1 = argv + ["--rot_method"] + [argv[0]]

        ts_search(argv1)

    if cmd in ("dimer-rotate", "lanczos-rotate"):
        valid_cmd = True

        # import right here in order not to import everything,
        # while using only one specific method:
        from pts.dimer_rotate import main as rotate

        rot = cmd.split("-")
        # First relevant argument might be special
        # Main expects that the very first element is only about itself
        argv1 = argv + ["--rot_method"] + [rot[0]]

        rotate(argv1)

    if cmd in methods:
        valid_cmd = True
        cmd_main = methods[cmd]
        cmd_main(argv[1:])

    if cmd in optic_methods:
        from pts.tools.path2plot import main as path2plot
        from pts.tools.tab2plot import main as tab2plot
        valid_cmd = True
        cmd_main = eval(cmd)
        cmd_main(argv[1:])

    if not valid_cmd:
        print >> sys.stderr, "pts: no such command:", cmd
        print >> sys.stderr, __doc__
        sys.exit(1)

#
# Example: calculations of energy/forces:
#
def single_point(argv):
    """Usage:

        energy --calculator <calculator file> <geometry file 1> [ <geometry file 2> ... ]

    or

        forces --calculator <calculator file> <geometry file 1> [ <geometry file 2> ... ]
    """
    from pts.io.cmdline import get_options, get_calculator
    import ase

    # first arg tells what to do:
    if argv[0] not in ("energy", "forces"):
        print >> sys.stderr, energy.__doc__
        sys.exit(1)

    # accepts only one option (so far):
    opts, args = get_options(argv[1:], long_options=["calculator="])

    # and one or more files molecular files:
    if len(args) < 1:
        print >> sys.stderr, energy.__doc__
        sys.exit(1)

    assert opts[0][0] == "--calculator"

    calculator = get_calculator(opts[0][1])

    for file in args:
        atoms = ase.io.read(file)
        # print atoms.get_positions()
        atoms.set_calculator(calculator)

        if argv[0] == "energy":
            # calculate total energy:
            e = atoms.get_potential_energy()

            # print results to stdout
            print e

        if argv[0] == "forces":
            # calculate total energy:
            f = atoms.get_forces()

            # print results to stdout
            print f
            print "" # separate blocks by a new line

def minimize(argv):
    """
    Usage:

        minimize --calculator <calculator file> <geometry file 1>

    This should  give back  the output of  the minimizer and  the last
    geometry.  This subcommand also accepts the following options:

    --maxit <n>

        Runs maximal n iterations (default is 100).

    --fmax  <fm>

        Is converged if max(f_on_atom) < fmax.

    --optimizer <opt>

        Uses opt  for optimization, opt  can be any of  the optimizers
        specified by ASE, like  LBGFS, BFGS, FIRE, GxOptimizer default
        is  BFGS take  care  that GxOptimizer  needs additional  input
        files.

    --format <format>

        Uses format as input and  output format for the geometry. This
        way  the name of  the input  file can  be arbitrary,  else ASE
        tries  to identify the  format by  the name.  In this  way the
        output geometry will be written into the file output_geometry.

    --atommask <mask>

        Only atoms  set True in mask  are optimized.  This  is done by
        reseting steps  and adjusting  forces, thus not  by optimizing
        only in a  subspace.  Note that in most  of the other routines
        masks are used to fix the variables, while in this context the
        atoms are fixed (Thus only one flag for each atom despite 3 in
        the other case).

    --restart <file>

        The  optimizer  (except  GxOptimizer)  have the  option  of  a
        restart file in which they  store data, like the Hessian. This
        data  allows by  a restart  of  the calculation  to take  this
        informations  into  consideration.  Be  aware  that they  will
        still  start with  the  geometry  given to  them  and use  the
        restart file only for  additional informations.  As default no
        such file is build, setting  the restart option they store the
        data  there,  if  it  exist  already  when  they  start  their
        calculation they do a restart.
    """
    from pts.io.cmdline import get_options, get_calculator, get_mask
    from ase.io import read, write
    from ase.constraints import FixAtoms

    if "--help" in argv:
        print minimize.__doc__
        sys.exit()


    opts, args = get_options(argv, long_options=["calculator=","atomsmask=", "optimizer=", "maxit=", "fmax=", "format=", "restart="])

    if len(args) != 1:
        print >> sys.stderr, "There is need of exactly one geometry file"
        print >> sys.stderr, minimize.__doc__
        sys.exit(1)

    # options default values, only calculator has to be overwritten
    mask = None
    maxit = 100
    fmax=0.05
    format = None
    optimizer = BFGS
    calculator = None
    restart = None

    for opt, value in opts:
        if opt == "--calculator":
            calculator = get_calculator(value)
        elif opt == "--maxit":
            maxit = int(value)
        elif opt == "--fmax":
            fmax = float(value)
        elif opt == "--optimizer":
            optimizer = eval("%s" % (value))
        elif opt == "--format":
            format = value
        elif opt == "--restart":
            restart = value
        elif opt == "--atomsmask":
            print "The following atoms were fixed"
            mask = get_mask(value)

    # this option has to be given!!
    assert calculator != None

    # if a special output is given, use it, else rely on
    # ASE to find it for itself. In principle format = None
    # is also the default case of ASE, thus one would be able
    # to forward it rigthaway. But in case ASE will ever change this
    # we select here explicitly
    if format == None:
        atoms = read(args[0])
    else:
        atoms = read(args[0], format = format)

    # so far only the FixAtoms constraint via a mask is an allowed
    # constraint, be aware that this constraint only works with reseting
    # the variables after an update step
    if mask != None:
       constr = FixAtoms(mask = mask)
       atoms.set_constraint(constr)

    atoms.set_calculator(calculator)

    # the optimizer, setup and run
    # in case ASE changes its default for restart, use it only
    # if it has not our default
    if restart == None:
        dyn = optimizer(atoms)
    else:
        dyn = optimizer(atoms, restart = restart)

    dyn.run(fmax = fmax, steps = maxit)

    # for format see as above, here the standard is to
    # standard output
    if format == None:
        atoms.write("-")
    else:
        atoms.write("output_geometry", format = format)


if __name__ == "__main__":
    main(sys.argv[1:])

# Default options for vim:sw=4:expandtab:smarttab:autoindent:syntax
