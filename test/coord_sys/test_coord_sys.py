import sys
import unittest
import os
import pickle

import numpy
import ase

import aof
import aof.coord_sys as cs
import aof.common as common
from aof.common import file2str

# whether to perform tests quickly
quick = True

# whether to perform visual tests, requiring user interaction
visual = False

def test_calc(**kwargs):
    if quick:
        return ase.EMT()
    else:
        return aof.ase_gau.Gaussian(**kwargs)

def geom_str_summ(s,n=2):
    """Summarises a string containing a molecular geometry so that very similar 
    geometries can be compared. For testing purposes."""

    import re
    numbers = re.findall(r"\d+\.\d*", s.lower())
    numbers = [str(round(float(i),n)) for i in numbers]

    symbols = re.findall(r"[a-z]+", s.lower())
    
    summary = symbols + numbers
    summary = ''.join(summary)

    return summary


class TestComplexCoordSys(aof.test.MyTestCase):

    def setUp(self):
        self.original_dir = os.getcwd()
        new_dir = os.path.dirname(__file__)
        if new_dir != '':
            os.chdir(new_dir)

    
    def tearDown(self):
        os.chdir(self.original_dir)

    def test_ZMatrix(self):
      
        hexane_zmt = file2str("hexane.zmt")

        z = cs.ZMatrix(hexane_zmt)
        print "Testing hexane.zmt -> xyz"
        self.assertEqual(geom_str_summ(z.xyz_str()), geom_str_summ(file2str("hexane.xyz")))

        print "Testing hexane2.zmt -> zmt"
        self.assertEqual(geom_str_summ(z.zmt_str()), geom_str_summ(file2str("hexane2.zmt")))

        z = cs.ZMatrix(file2str("benzyl.zmt"))
        print "Testing benzyl.zmt -> xyz"
        self.assertEqual(geom_str_summ(file2str("benzyl.xyz")), geom_str_summ(z.xyz_str()))

    def test_ZMatrix_BigComplex(self):
        print "Test Sum of all Cartesian Coordinates"
        z = cs.ZMatrix(file2str("bigComplex.zmt"))
        xyz_str = z.xyz_str()

        import re
        list = re.findall(r"[+-]?\d+\.\d*", xyz_str)
        var_sum = sum([float(n) for n in list])

        self.assertAlmostEqual(183.156839765, var_sum, 3)
        

    def test_ZMatrixiExceptions(self):
        #  no space between
        input1 = 'N\nH 1 hn\nH 1 hn 2 hnh\nH 1 hn 2 hnh 3 120.1\nhn 1.2\nhnh 109.5\n'

        # no variables
        input2 = 'N\nH 1 hn\nH 1 hn 2 hnh\nH 1 hn 2 hnh 3 120.1\n'
        input3 = ""

        # missing variable
        input4 = 'N\nH 1 hn\nH 1 hn 2 hnh\nH 1 hn 2 hnh 3 120.1\n\nhn 1.2\n'
 
        self.assertRaises(Exception, cs.ZMatrix, input1)
        self.assertRaises(Exception, cs.ZMatrix, input2)
        self.assertRaises(Exception, cs.ZMatrix, input3)
        self.assertRaises(Exception, cs.ZMatrix, input4)


    def test_get_transform_matrix(self):
        common.ANGSTROMS_TO_BOHRS = 1.8897

        common.DEG_TO_RAD = numpy.pi / 180.
        RAD_TO_DEG = 180. / numpy.pi

        m1 = file2str("CH4.zmt")
        z = cs.ZMatrix(m1)
        m, e = z.get_transform_matrix(z.get_internals())

        print "Testing that the numerical diff errors are small"
        self.assert_(numpy.linalg.norm(e) < 1e-8)

        
        z = cs.ZMatrix(file2str("benzyl.zmt"))
        m, e = z.get_transform_matrix(z.get_internals())

        print "Testing numerical differentiation"
        max_rms_err = 1e-8
        err_msg = "Numerical differentiation RMS error should be less than " + str(max_rms_err) + " but errors were: " + str(e)
        self.assert_(numpy.linalg.norm(e) / len(e) < max_rms_err, err_msg)

        print "Testing generation of forces coordinate system transform matrix"

        zmt_grads_from_benzyl_log = numpy.array([-0.02391, -0.03394, -0.08960, -0.03412, -0.12382, -0.15768, -0.08658, -0.01934, 0.00099, 0.00000, -0.00541, 0.00006, -0.00067, 0.00000, -0.00556, 0.00159, 0.00000, -0.00482, -0.00208])
        xyz_grads_from_benzyl_xyz_log = numpy.array([0.023909846, 0.0, 0.034244932,  0.053971884, 0.0, -0.124058188, -0.004990116, 0.000000000, 0.000806757, -0.005402561, 0.000000000, -0.006533931,  0.008734562, 0.000000000, -0.006763414, -0.002889556, 0.000000000, -0.013862257, -0.072130600, 0.000000000, 0.125686058, -0.005409690, 0.000000000, 0.000029026, -0.002717236, 0.000000000, -0.005359264, 0.002107675, 0.000000000, -0.005198587, 0.004815793, 0., 0.001008869])

        calculated_zmt_grads = numpy.dot(m, xyz_grads_from_benzyl_xyz_log)

        """Gradients in Gaussian are in Hartree/Bohr or radian, but the transform 
        matrix generated by the ZMatrix class has units of angstroms/bohr or 
        degree. For this reason, when comparing Gaussian's gradients in terms of
        z-matrix coordinates (in benzyl.log) with those computed by transforming 
        Gaussian's forces in terms of cartesians (in benzyl_zmt.log), one needs to 
        multiply the angular forces from benzyl.log by the following factor:
        (ANGSTROMS_TO_BOHRS * RAD_TO_DEG). That's what the following two lines 
        are for."""
        for i in [2,4,6,7,8,9,11,12,13,15,16,18]:
            calculated_zmt_grads[i] *= (common.ANGSTROMS_TO_BOHRS)

        self.assertAlmostEqualVec(calculated_zmt_grads, zmt_grads_from_benzyl_log, 1e-3)
#        print "xyz_grads_from_benzyl_log:", xyz_grads_from_benzyl_xyz_log
#        print "zmt_grads_from_benzyl_log:", zmt_grads_from_benzyl_log
#        print "calculated_zmt_grads:", calculated_zmt_grads

    def test_opts(self):
        z = cs.ZMatrix(file2str("butane1.zmt"))
        new_coords = z.get_internals() * 1.15

        z.set_internals(new_coords)

        string_rep = z.xyz_str()

        z.set_calculator(test_calc())
        dyn = ase.LBFGS(z)

        print "Running z-matrix optimisation"
        dyn.run(steps=5)

        e1 = z.get_potential_energy()

        xyz = cs.XYZ(string_rep)
        xyz.set_calculator(test_calc())
        dyn = ase.LBFGS(xyz)

        print "Running cartesian optimisation"
        dyn.run(steps=5)

        e2 = xyz.get_potential_energy()

        self.assert_(e1 < e2)

    def test_Anchoring(self):

        self.assertRaises(cs.ComplexCoordSysException, cs.RotAndTrans, numpy.array([0.,0.,0.,0.,0.,0.]))

        # Generates a series of rotated molecular geometries and views them.
        a = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,1.,1.,1.]))
        z = cs.ZMatrix(file2str("butane1.zmt"), anchor=a)

        print z.get_internals()
        atoms1 = z.atoms.copy()

        alphas = numpy.arange(0., 1., 0.01) * 2 * numpy.pi
        vs     = numpy.arange(0., 1., 0.01)
        geoms_list = []

        for alpha, v in zip(alphas, vs):
            w = numpy.array([numpy.cos(alpha / 2)])

            vec = common.normalise([1,v,-v])
            vec = numpy.sin(alpha / 2) * vec
            q = numpy.hstack([w, vec])
            v = numpy.array([1.,1.,1.])
            a.set(numpy.hstack([q,v]))
            geoms_list.append(z.atoms.copy())

        if visual:
            ase.view(geoms_list)

    def test_ComplexCoordSys(self):

        x = cs.XYZ(file2str("H2.xyz"))

        a_h2o1 = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,3.,1.,1.]), parent=x)
        a_h2o2 = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,1.,1.,1.]), parent=x)
        a_ch4  = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,1.,-1.,1.]), parent=x)

        h2o1 = cs.ZMatrix(file2str("H2O.zmt"), anchor=a_h2o1)
        h2o2 = cs.ZMatrix(file2str("H2O.zmt"), anchor=a_h2o2)
        ch4  = cs.ZMatrix(file2str("CH4.zmt"), anchor=a_ch4)

        parts = [x, h2o1, h2o2, ch4]

        ccs = cs.ComplexCoordSys(parts)
        ccs.set_calculator(test_calc())

        dyn = ase.LBFGS(ccs)

        list = []
        for i in range(8):
            list.append(ccs.atoms.copy())
            dyn.run(steps=1,fmax=0.01)
            print "Quaternion norms:", a_h2o1.qnorm, a_h2o2.qnorm, a_ch4.qnorm

        list.append(ccs.atoms.copy())

        if visual:
            ase.view(list)

    def form_ccs1(self):
        """Forms a complex coordinate system object from a few bits and pieces."""
        x = cs.XYZ(file2str("H2.xyz"))

        a_h2o1 = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,3.,1.,1.]), parent=x)
#        a_h2o2 = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,1.,1.,1.]), parent=x)
#        a_ch4  = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,1.,-1.,1.]), parent=x)

        h2o1 = cs.ZMatrix(file2str("H2O.zmt"), anchor=a_h2o1)
#        h2o2 = cs.ZMatrix(file2str("H2O.zmt"), anchor=a_h2o2)
#        ch4  = cs.ZMatrix(file2str("CH4.zmt"), anchor=a_ch4)

        parts = [x, h2o1] #, h2o2, ch4]

        ccs = cs.ComplexCoordSys(parts)

        return ccs, x, h2o1, a_h2o1#, h2o2, ch4, a_h2o2, a_ch4

    def form_ccs2(self):
        """Forms a complex coordinate system object from a few bits and pieces."""
        x = cs.XYZ(file2str("H2.xyz"))

        a_h2o1 = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,3.,1.,1.]), parent=x)
        a_h2o2 = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,1.,1.,1.]), parent=x)
        a_ch4  = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,1.,-1.,1.]), parent=x)

        h2o1 = cs.ZMatrix(file2str("H2O.zmt"), anchor=a_h2o1)
        h2o2 = cs.ZMatrix(file2str("H2O.zmt"), anchor=a_h2o2)
        ch4  = cs.ZMatrix(file2str("CH4.zmt"), anchor=a_ch4)

        parts = [x, h2o1] #, h2o2, ch4]

        ccs = cs.ComplexCoordSys(parts)

        return ccs, x, h2o1, a_h2o1, h2o2, ch4, a_h2o2, a_ch4

    def form_ccs_waters(self, n):
        """Forms a ComplexCoordSys object with n water molecules with random orientations."""

        from random import random

        r = numpy.arange(numpy.ceil(n**0.333))
        water_positions = [numpy.array([x,y,z]) for x in r for y in r for z in r]
        water_positions = water_positions[:n]
        print water_positions
        
        parts   = []
        var_types = ""
        for pos in water_positions:
            rs = [random() for i in range(4)]
            quat = numpy.array(rs)
            quat = quat / numpy.linalg.norm(quat)
            gps = numpy.hstack([quat, pos*3])
            a = cs.RotAndTrans(gps)
            h2o = cs.ZMatrix(file2str("H2O.zmt"), anchor=a)

            parts.append(h2o)

            # setup mask to identify nature of variables later
            var_types += "".join(["i" for j in range(h2o._dims)])
            var_types += "rrrrppp"

        ccs = cs.ComplexCoordSys(parts)

        return ccs, var_types


    def test_var_mask_big_water_opt(self):

        print "Running optimisation tests with masking of variables:"
        print "    Lots of water molecules with internal and rotational coordinates frozen."

        ccs, var_types = self.form_ccs_waters(16)

        def gen_mask(c):
            if c == 'i':
                return False
            elif c == 'r':
                return False
            elif c == 'p':
                return True
            else:
                raise False

        mask = map(gen_mask, var_types)
        ccs.set_var_mask(mask)
        ccs.set_calculator(test_calc())

        opt = ase.LBFGS(ccs)
        list = []
        for i in range(8):
            opt.run(steps=1,fmax=0.0)
            list.append(ccs.atoms.copy())

        if visual:
            ase.view(list)


    def test_var_mask_basic(self):

        print "Running basic tests with masking of variables"

        ccs1, _, _, _ = self.form_ccs1()
        ccs2, _, _, _, _, _, _, _ = self.form_ccs2()
        benzyl = cs.ZMatrix(file2str("benzyl.zmt"))

        sys_list = [ccs1, ccs2, benzyl]

        tf = lambda i: i % 2 == 0
        for sys in sys_list:
            mask = map(tf, range(sys.dims))

            sys.set_var_mask(mask)

            # check that computed dimensionality is correct
            self.assert_(sum(sys._var_mask) == sys.dims)

            # check that masking/demasking is ok
            self.assert_((sys._coords == sys._demask(sys.get_internals())).all())
            should_be = sys._demask(sys._mask(sys._coords))
            self.assert_((sys._coords == should_be).all())

            # check that state is not altered by a few function calls
            before = sys._coords.copy()
            sys.int2cart(sys.get_internals())
            after = sys._coords.copy()
            self.assert_((before == after).all())

            # play with state, check that forces don't change
            sys.set_calculator(test_calc())
            f1 = sys.get_forces()
            before = sys.get_internals()
            sys.set_internals(before*1.2)

            sys.get_forces()

            sys.set_internals(before)
            f2 = sys.get_forces()

            self.assert_((f1 == f2).all())


    def test_ComplexCoordSys_var_mask_opt(self):

        print "Running tests with masking of variables"

        #ch4  = cs.ZMatrix(file2str("CH4.zmt"))
        ccs, x, h2o1, a_h2o1 = self.form_ccs1()#, h2o2, ch4, a_h2o2, a_ch4 = self.form_ccs()

        ccs.set_calculator(test_calc())

        #m = [True for i in range(0)] + [True for i in range(ccs.dims)]
        parts = [x, h2o1, a_h2o1]#, h2o2, a_h2o2, ch4, a_ch4]
        dims = [p._dims for p in parts]
        print dims
        torf = lambda d, f: [f for i in range(d)]
        fs = [False, False, True]#, True, False, False, False]
        m1 = [torf(d,f) for d,f in zip(dims, fs)]

        print m1
        m = [m_ for d,f in zip(dims, fs) for m_ in torf(d,f)]

        print m
        
        mask = numpy.array(m)
        ccs.set_var_mask(mask)

        self.assert_(sum(ccs._var_mask) == ccs.dims)

        self.assertAlmostEqualVec(ccs._coords, ccs._demask(ccs.get_internals()))

        before = ccs._coords.copy()
        print ccs.int2cart(ccs.get_internals())
        after = ccs._coords.copy()
        self.assert_((before == after).all())

        print "_coords", ccs._coords

        if visual:
            ase.view(ccs.atoms)
        print "_coords", ccs._coords

        print ccs.get_internals()

        if visual:
            ase.view(ccs.atoms)

        dyn = ase.LBFGS(ccs)

        list = []
        for i in range(8):
            list.append(ccs.atoms.copy())
            dyn.run(steps=1,fmax=0.01)
#            print "Quaternion norms:", a_h2o1.qnorm, a_h2o2.qnorm, a_ch4.qnorm

        list.append(ccs.atoms.copy())

        if visual:
            ase.view(list)

    def test_ComplexCoordSys2(self):

        x = cs.XYZ(file2str("H2.xyz"))
        a = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,3.,1.,1.]), parent=x)
        z = cs.ZMatrix(file2str("butane1.zmt"), anchor=a)

        parts = [x, z]

        ccs = cs.ComplexCoordSys(parts)
        ccs.set_calculator(test_calc())

        print ccs.get_potential_energy()
        print ccs.get_forces()

        dyn = ase.LBFGS(ccs)

        list = []
        for i in range(8):
            dyn.run(steps=1,fmax=0.01)
            list.append(ccs.atoms.copy())

        if visual:
            ase.view(list)

    def test_CoordSys_pickling(self):

        print "Creating a Z-matrix, pickling it, then performing an dientical"
        print "optimisation on each one, then checking that the forces are identical."

        z1 = cs.ZMatrix(file2str("butane1.zmt"))

        s = pickle.dumps(z1)
        z1.set_calculator(test_calc())
        opt = ase.LBFGS(z1)
        opt.run(steps=4)

        forces1 = z1.get_forces()

        z2 = pickle.loads(s)
        z2.set_calculator(test_calc())

        opt = ase.LBFGS(z2)
        opt.run(steps=4)

        forces2 = z2.get_forces()
        self.assert_((forces1 == forces2).all())

    def test_ComplexCoordSys_pickling(self):
      
        calc = ase.EMT()

        x = cs.XYZ(file2str("H2.xyz"))
        a = cs.RotAndTrans(numpy.array([1.,0.,0.,0.,3.,1.,1.]), parent=x)
        z = cs.ZMatrix(file2str("butane1.zmt"), anchor=a)

        parts = [x, z]

        ccs = cs.ComplexCoordSys(parts)
        ccs.set_calculator(calc)
        forces0 = ccs.get_forces()

        ccs_pickled = pickle.loads(pickle.dumps(ccs))
        ccs_pickled.set_calculator(calc)

        forces_pickled0 = ccs.get_forces()

        dyn = ase.LBFGS(ccs_pickled)
        dyn.run(steps=3)

        forces_pickled1 = ccs_pickled.get_forces()

        dyn = ase.LBFGS(ccs)
        dyn.run(steps=3)

        forces1 = ccs.get_forces()

        self.assert_((forces0 == forces_pickled0).all())
        self.assert_((forces1 == forces_pickled1).all())
        self.assert_((forces0 != forces1).any())



def suite():
    return unittest.TestLoader().loadTestsFromTestCase(TestComplexCoordSys)

if __name__ == "__main__":
    visual = True
    quick = True
    unittest.TextTestRunner(verbosity=2).run(unittest.TestSuite([TestComplexCoordSys("test_var_mask_big_water_opt")]))


