02/04/2009
----------

TODO
 - print / read new papers
 - see what happens with numpy bfgs minimiser when linesearch is removed

 08/04/2009
 ----------

  - Why do they use a runge kutta method to solve the equations when all they 
    want to do is minimise withing a trust region?
  - Is it because it becomes tricky when you have a multidimentional function?

17/04/2009
----------

 - string starts going crazy after a few macro iterations.
 - could be because the hessian is getting confused after it gets updated 
   based on gradient from re-spaced points.
 - will the methods described in the paper fix this?
 - *** mostly fixed by makign trust radius better
 - *** remaining problem seems to be that some points move far slower than 
   others, causing kinks in the string
 
20/04/2009
----------
 - above problem fixed by using adaptive step sizes

Tasks / wish list
----------
 - implement final parts of QSM
 - investigate OpenBabel and cclib (DONE)
 - implement calc queueing, remembering and multithreading (DONE)
 - improve logging / error reporting (DONE for sched.py)
 - get code to use new scheduler (DONE - need to test)
 - test NEB again (DONE)
 - compare SciPy BFGS optimiser with mine
 - test growing string with QSM (DONE)
 - implement test for oscillating string/band
 - test on other potentials
 - uniform interface for searchers

12/06/2009
----------
 - need to implement: mol_interface.get_reagent_coords()
 - also convert relevant functions in mol_interface to operate on an arbitrary list of input molecules

15/06/2009
----------
 - Program runs but seg faults (in Fortan code) when using the l_bfgs_b solver 
   and has (normal(?)) problem when using standard bfgs solver.
 - todo next:
   - try using simple gradient descent (DONE)
   - try using dummy qchem driver, i.e. analytical potential
   - check units for gradients, etc. (DONE [i think])
   - look at paper for Fast Marching Method... esp. interpolation method

16/06/2009
----------
 - discovered problem with forces, usual sign problem i.e. grads = -1*forces
 - seems to work with simple gradient descent
 - TODO:
   - see above

25/06/2009
----------
 - for some reason:
   - when the openbabel python module is loaded, the l_bfgs_b solver crashes 
      with a segmentation fault.
      TODO: test if it crashes when openbabel is loaded in my molinterface.py code
 - l_bfgs_b cannot find as good a minimum as the gradient descent solver
   TODO: check if this was the same when running test_NEB()

09/07/2009
----------
 - openbabel being loaded seems to cause the optimiser to crash
   - to work around this, have coded a new z-matrix to cartesian 
     converter in python
 TODO:
 - check again how the various optimisers are behaving for an analytical potential
   - how is the horizontal axis generated? force? energy? DONE
 - run qc jobs for pseudo-analytical plot (DONE)
   - jobs setup and ready to run in jobs/screaning
     - lots of these have convergence issues => what to do?
       - use mm?
 - zmatrix.py works
   - need to add function/property to return total number of atoms / 
     variables / etc, see http://docs.python.org/library/functions.html

13/07/2009
----------
 - started writing paragauss.py to parse gxfile and create z-matrix
 - need to find out exactly how paragauss is invoked
 - program seems to be working for rotation of ethane
   TODO Next:
   ----------
   - print energy of each bead when dumping DONE
   - report:
     - Distance between beeds
     - angle between beads. DONE

14/07/2009
----------
 TODO
 - test on larger example, e.g. amino acid in paper (DONE)
 - get working with Python z-matrix code => convert test functions first
 - get working with direct z-matrix gradients from Gaussian
 - input params class
 - shepard interpolation
 - paragauss parser/generator
 - compile paragauss (NO, NOT ANY MORE)
   - get mpi
   - http://intranet.theochem.tu-muenchen.de/wiki/index.php/Building_ParaGauss

15/07/2009
----------
 - some unit tests for zmatrix.py added under test/
 - started converting to use new zmatrix conversion code
   - NEED TO GO OVER HOW I'VE DONE THIS

16-17/07/2009
-------------
 - finished conversion to new zmatrix code
 - fixed thread safety bug in molinterface.py
 - got prog to record step sizes and print at the end

 TODO
  - look at ase/optimize/gxfile.py
  - it contains gradient extraction code

20/07/2009
----------
 - setup modules correctly, e.g. have __init__.py
   - read http://mail.python.org/pipermail/python-list/2005-July/330237.html
 - setup top level testing module
 - check units of energy: cclib returns units in electron volts

29/07/2009
----------
 - script to run paragauss

input=$1

# user configurable options
output=$input.log
template_directory=/users/hugh/pgjobs/original
isodir=isolate-$input
runpg_path="~alexei/bin/runpg"
exe_path="~alexei/exe/openmpi/mainscf_V3.1.4b8-64"
opt_file=opt_file_path
cleanup=1 # uncomment if undesired

copy -r $template_directory $isodir
copy $input $isodir/gxfile
cd $isodir

# this line runs the program
$runpg_path $exe_path $opt_file_path

cd ..
cp $isodir/gxfile $output
if [ $cleanup ]; then
    optional rm -r $isodir
fi

--------

 - improved the response when a control break/exception is thrown
 - did some thinking about how when one thread experiences an exception, the 
   others should be stopped
 - 2 levels:
   - when one thread dies, no further threads should be started
   - when one thread dies, all running threads should be actively stopped
 - perhaps use the event() method (see example below)
 - might need to kill qchem processes also

import thread
import time
from threading import *


def event_set(event):

    time.sleep(2)

    while 1 :
        
        #we wait for the flag to be set.
        while not event.isSet():
            event.wait()

        print currentThread(),"...Woken Up"
        event.clear()



if __name__=="__main__":

    event=Event()
    
    thread.start_new_thread(event_set,(event,))

    while 1:

        event.set()
        print event, " Has been set"
        time.sleep(2)

04/08/2009
----------
 - got paragauss wrapper running
 - started writing paragauss interface, look at most recent changes in 
   molinterface.py
 - need to hack gxfile.gxwrite so that it returns a string

OTHER THOUGHTS / TODO
---------------------
 - think of 3D analytical potential?
 - add test for when input geoms are almost identical
 - need to deal with situation when |dih1 - dih2| > 180. (DONE)
 - punch for restart
 - need to extract forces from other part of gaussian file, due to ****** when forces are high (DONE)


10/08/2009
----------
 - discovered concurrency issue when converting from z-matrix to cartesians
 - fixed by providing locks in the interface to ZMatrix which must be aquired before performing 
   activities which modify an instance's state

   THOUGHTS:
    - maybe this is not the best way to do this? Maybe I should only provide stateless functions?
      - need to think about this...

16/09/2009
----------
 - To set affinity of process 11044 to processor 0:
   $ taskset -cp 0 11044
 - monitor disk activity
   $ iostat -m -d 4

 - Need to unify interface for all path_rep objects. (DONE)
   - attributes:
       history
       beads_count
       bead_forces
       bead_pes_energies
       state_vec

   - functions
       get_bead_coords()
       obj_func()
       get_state_as_array()
       obj_func_grad()

TODO
----
 - check that the above functions are implemented in GrowingString (DONE)
 - write __str__ function for GrowingString to help test if string is really working (DONE)

18/09/2009
----------
 - Qs for Alexei / Vasp users
   - how do you want to specify your input?
   - must you specify all the parameters all the time? 

 - there is a long list (comprehensive?) in ASE VASP interfave of input keys
